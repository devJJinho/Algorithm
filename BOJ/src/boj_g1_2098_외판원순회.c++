#include <iostream>
#define INF 9999999
using namespace std;

/*
@author  :  Jinho Jeong
@date    :  2021.09.08

*난이도 : G1
*개인 풀이 시간 : 1hour 
*개인 난이도 : 3/5 
*분류 : 재귀, DP, 비트마스크
*풀이 : 풀이를 보고 풀었다.
       dp배열의 선언에 방식이 여러가지가 있었다. 그 중에서 진짜 메모제이션을 사용해서 중복되는 연산을 방지한 점화식은 아래와 같았다.
       이 점화식은 재귀 완탐의 방식에 연관이 깊다.
           3   / 1
          /----
         /     \ 2
       -<
         \    /-- 4
          \---
           6  \-- 5

        위와 같이 3 다음에 6을 본다 하지만 3이 방문 했을때 가능한 모든 경후에 대해서 최소값을 구해서 3에서의 dp를 업데이트 했다면,
        다음에 같은 상황을 조회한다면 dp 값만 사용하면 된다. 이것은 엄청난 오버헤드를 줄여주는 기술이다.
        dp배열의 정의 : dp[현재점][이때까지 방문한 점]=i  현재 상태(현재점, 방문 지점)에서 0까지의 최소 거리, 0에서 시작을 전제로 했기때문에 현재 점에서 가능한 최소 순회거리. 

*느낀점 : 점화식과 코드는 이해 할 수 있었으나 dp 구조 짜는게 어렵다. 이런 영감은 어떻게 얻는 것인가..
        현재 재귀에서 하위 재귀를 모두 종합해서 최소를 찾고 return하는 방식은 생소했지만 많이 쓰일듯하다.
        dp 구조를 짜는 방식 중에 각 인덱스를 기준으로 문제상황을 나눌 수 있는지가 중효하다.
        이 문제의 경우 한번 방문한 정점은 다시 가지 않기 때문에 현재 점점으로 dp 상황을 나눌 수 있다. 그리고 그것만으론 부족하기 때문에 2차원에 현재까지 방문한 정점을 넣었다.
        
*/

int cost[16][16];
int dp[16][(1<<16)+1]={0};
int all,n;
int recul(int cur,int stat){
    //모두 방문한 경우 마지막 점에서 0으로 갈 수 없다면 INF 반환 => 최소값 비교를 계속하기 때문에 적당히 큰 값을 반환하면 해당 경로는 후보군에서 탈락한다.
    if(stat==all){
        if(!cost[cur][0]) return INF;
        return cost[cur][0];
    }
    //같은 상황에 대해서 탐색한 적이 있으면 dp 값이 있을것이다. => dp 값 반환
    if(dp[cur][stat]) return dp[cur][stat];
    int dst=INF;
    //현재 상황에서 가능한 모든 경우를 탐색한다. 
    for(int i=0;i<n;i++){
        if(!cost[cur][i]||stat&1<<i) continue;
        //재귀를 부르기 때문에 현재 위치에서 마지막 depth까지 다 탐색하고 그 경로를 반환한다.
        dst=min(dst,recul(i,stat|1<<i)+cost[cur][i]);
    }
    //현재 값에 대한 dp는 모두 탐색 이후 최소값으로 업데이트한다.
    dp[cur][stat]=dst;
    //현재 재귀에서 return해야 이전 depth 재귀에서 경로를 얻을 수 있다.
    return dp[cur][stat];
}

int main(){
    cin>>n;
    all=(1<<n)-1;
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            cin>>cost[i][j];
        }
    }
    cout<<recul(0,1)<<endl;
    return 0;
}